Demonstrations of softirqslower, the Linux eBPF/bcc version.

The softirqslower tool traces two critical latency dimensions of softirq handling:

1. Softirq execution duration - Measures the actual processing time consumed by
softirq handlers (from entry to completion)
2. Wakeup-to-execution latency - Tracks the delay between softirq wakeup
triggers (via raise_softirq()) and handler execution start

For example:

# softirqslower

Tracing softirq latency higher than 10000 us... Hit Ctrl-C to end.

19:55:25 softirq runtime: rcu took 360653 us (360 ms), on CPU:70, comm:swapper/70
19:55:25 irq(hard) to softirq: net_rx took 93506 us (93 ms), on CPU:0, comm:cat
19:55:25 irq(hard) to softirq: tasklet took 93659 us (93 ms), on CPU:0, comm:cat
19:55:25 irq(hard) to softirq: rcu took 93651 us (93 ms), on CPU:0, comm:cat
19:55:25 irq(hard) to softirq: timer took 49952 us (49 ms), on CPU:0, comm:cat
19:55:25 irq(hard) to softirq: net_rx took 49906 us (49 ms), on CPU:0, comm:cat
19:55:25 irq(hard) to softirq: rcu took 49949 us (49 ms), on CPU:0, comm:cat
19:55:25 irq(hard) to softirq: net_rx took 11238 us (11 ms), on CPU:0, comm:cat
19:55:25 irq(hard) to softirq: sched took 11460 us (11 ms), on CPU:0, comm:cat
19:55:25 irq(hard) to softirq: net_rx took 10412 us (10 ms), on CPU:0, comm:cat
19:55:25 irq(hard) to softirq: net_rx took 15964 us (15 ms), on CPU:0, comm:cat
19:55:25 irq(hard) to softirq: net_rx took 12573 us (12 ms), on CPU:0, comm:cat
19:55:25 irq(hard) to softirq: tasklet took 12632 us (12 ms), on CPU:0, comm:cat
19:55:25 irq(hard) to softirq: net_rx took 11387 us (11 ms), on CPU:0, comm:cat
19:55:25 irq(hard) to softirq: tasklet took 11476 us (11 ms), on CPU:0, comm:cat
[...]

The trace results reveal softirq events with measured latencies beyond the
10,000Î¼s threshold.

The 'softirq runtime' metric indicates the actual execution duration of softirq
handlers. This reveals which softirq types (NET_RX, TASKLET, etc.) are consuming
excessive processing time.

The 'hardirq-to-softirq latency' metric measures the delay between when a
softirq is triggered (from hardware interrupt context) until its execution
begins. Elevated values here suggest either: Preemption by higher-priority
kernel tasks/threads or others

USAGE message:

# softirqslower -h
usage: softirqslower.py [-h] [-c CPU] [min_us]

Trace slow soft IRQ (interrupt).

positional arguments:
  min_us             minimum softirq latency to trace, in us (default 10000)

optional arguments:
  -h, --help         show this help message and exit
  -c CPU, --cpu CPU  trace this CPU only

examples:
    ./softirqslower        # trace softirq latency higher than 10000 us (default)
    ./softirqslower 100000 # trace softirq latency higher than 100000 us
    ./softirqslower -c 1   # trace softirq latency on CPU 1 only
