Demonstrations of exitsnoop.

This Linux tool traces all process terminations and reason, it
    - is implemented using BPF, which requires CAP_SYS_ADMIN and
      should therefore be invoked with sudo
    - traces sched_process_exit tracepoint in kernel/exit.c
    - includes processes by root and all users
    - includes processes in containers
    - includes processes that become zombie

The following example shows the termination of the 'sleep' and 'bash' commands
when run in a loop that is interrupted with Ctrl-C from the terminal:

# ./exitsnoop.py > exitlog &
[1] 18766
# for((i=65;i<100;++i)); do bash -c "sleep 0.25;exit $i";done
^C
# fg
./exitsnoop.py > exitlog
^C
# cat exitlog
COMM             PID    PPID   EXIT_CODE
sleep            18777  18776  0
bash             18776  18676  FAIL: exit_code: 65
sleep            18779  18778  0
bash             18778  18676  FAIL: exit_code: 66
sleep            18782  18781  0
bash             18781  18676  FAIL: exit_code: 67
sleep            18784  18783  0
bash             18783  18676  FAIL: exit_code: 68
sleep            18786  18785  0
bash             18785  18676  FAIL: exit_code: 69
sleep            18788  18787  0
bash             18787  18676  FAIL: exit_code: 70
sleep            18790  18789  KILL: signal: 2 (INT)
bash             18789  18676  KILL: signal: 2 (INT)

The output shows the process/command name (COMM), the PID,
the process that will be notified (PPID) and the reason for
the process exit (EXIT_CODE).

A -t option can be used to include a timestamp column, it shows local time
followed by time since exitsnoop started in seconds and a -x option to show
only fails, which excludes processes that exit with 0 code:

# ./exitsnoop.py -t -x > exitlog &
[1] 19104
# for((i=65;i<100;++i)); do bash -c "sleep 0.25;exit $i";done
^C
# fg
./exitsnoop.py -t -x > onlyfails
^C
# cat onlyfails
TIME:CDT TIME(s)  COMM             PID    PPID   EXIT_CODE
18:10:40 0.00     bash             19110  18676  FAIL: exit_code: 65
18:10:40 0.26     bash             19113  18676  FAIL: exit_code: 66
18:10:40 0.51     bash             19115  18676  FAIL: exit_code: 67
18:10:40 0.77     bash             19117  18676  FAIL: exit_code: 68
18:10:41 1.03     bash             19119  18676  FAIL: exit_code: 69
18:10:41 1.29     bash             19121  18676  FAIL: exit_code: 70
18:10:41 1.39     sleep            19125  19124  KILL: signal: 2 (INT)
18:10:41 1.39     bash             19124  18676  KILL: signal: 2 (INT)

The output shows the local time and zone (TIME:CDT), followed by the
time since exitsnoop started in seconds with hundredth of a second
resolution.  Successful exits are excluded.


USAGE message:

# ./exitsnoop.py -h
usage: exitsnoop.py [-h] [-t] [-p PID] [-x]

Trace all process termination (exit, fatal signal)

optional arguments:
  -h, --help         show this help message and exit
  -t, --timestamp    include timestamp on output
  -p PID, --pid PID  trace this PID only
  -x, --failed       trace fails, exclude exit(0)

examples:
    sudo exitsnoop           # trace all process termination
    sudo exitsnoop -x        # trace only fails, exclude exit(0)
    sudo exitsnoop -t        # include timestamps
    sudo exitsnoop -p 181    # only trace PID 181

Exit status:

    0 EX_OK        Success
    2              argparse error
   70 EX_SOFTWARE  syntax error detected by compiler, or
                   verifier error from kernel
   77 EX_NOPERM    Need sudo (CAP_SYS_ADMIN) for BPF() system call

About process termination in Linux
----------------------------------

A program/process on Linux terminates normally
    - by explicitly invoking the exit( int ) system call
    - in C/C++ by returning an int from main(),
      ...which is then used as the value for exit()
    - by reaching the end of main() without a return
      ...which is equivalent to return 0 (C99 and C++)
  Notes:
    - Linux keeps only the least significant eight bits of the exit value
    - an exit value of 0 means success
    - an exit value of 1-255 means an error

A process terminates abnormally if it
    - receives a signal which is not ignored or blocked and has no handler
      ... the default action is to terminate with optional core dump
    - is selected by the kernel's "Out of Memory Killer",
      equivalent to being sent SIGKILL (9), which cannot be ignored or blocked
  Notes:
    - any signal can be sent asynchronously via the kill() system call
    - synchronous signals are the result of the CPU detecting
      a fault or trap during execution of the program, a kernel handler
      is dispatched which determines the cause and the corresponding
      signal, examples are
        - attempting to fetch data or instructions at invalid or
          privileged addresses,
        - attempting to divide by zero, unmasked floating point exceptions
        - hitting a breakpoint

Linux keeps process termination information in 'exit_code', an int
within struct 'task_struct' defined in <linux/sched.c>
    - if the process terminated normally:
        - the exit value is in bits 15:8
        - the least significant 8 bits of exit_code are zero (bits 7:0)
    - if the process terminates abnormally:
        - the signal number (>= 1) is in bits 6:0
        - bit 7 indicates a 'core dump' action, whether a core dump was
          actually done depends on ulimit.

Success is indicated with an exit value of zero.
The meaning of a non zero exit value depends on the program.
Some programs document their exit values and their meaning.
This script uses exit values as defined in <include/sysexits.h>

References:

   https://github.com/torvalds/linux/blob/master/kernel/exit.c
   https://github.com/torvalds/linux/blob/master/arch/x86/include/uapi/asm/signal.h
   https://code.woboq.org/userspace/glibc/misc/sysexits.h.html

